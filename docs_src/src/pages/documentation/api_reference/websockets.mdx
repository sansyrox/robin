export const description =
  'On this page, weâ€™ll dive into the different conversation endpoints you can use to manage conversations programmatically.'


## WebSockets {{ tag: 'GET', label: '/hello_world' }}

<Row>
<Col>
To handle real-time communication, Batman learned how to work with WebSockets. He created a WebSocket class and wrapped it around his Robyn app:
</Col>
  <Col sticky>

    <CodeGroup title="Request" tag="GET" label="/hello_world">

    ```python {{ title: 'untyped' }}
    from robyn import Robyn, jsonify, WebSocket

    app = Robyn(__file__)
    websocket = WebSocket(app, "/web_socket")

    @websocket.on("message")
    def connect():
        return "Hello world, from ws"

    @websocket.on("close")
    def close():
        return "Goodbye world, from ws"

    @websocket.on("connect")
    def message():
        return "Connected to ws"


    ```

    ```python {{title: 'typed'}}
    from robyn import Robyn, jsonify, WebSocket

    app = Robyn(__file__)
    websocket = WebSocket(app, "/web_socket")

    @websocket.on("message")
    def connect():
        return "Hello world, from ws"

    @websocket.on("close")
    def close():
        return "Goodbye world, from ws"

    @websocket.on("connect")
    def message():
        return "Connected to ws"


    ```
    </CodeGroup>
  </Col>
</Row>
<Row>

  <Col>
    For sending a message to the client, Batman used the `send` method. 
  </Col>
  <Col sticky>
    <CodeGroup title="Request" tag="GET" label="/hello_world">

      ```python {{ title: 'untyped' }}

        @websocket.on("message")
        async def message(ws, msg, global_dependencies) -> str:
            global websocket_state
            websocket_id = ws.id
            state = websocket_state[websocket_id]
            resp = ""
            if state == 0:
                resp = "Whaaat??"
                await ws.async_broadcast("This is a broadcast message")
                ws.sync_send_to(websocket_id, "This is a message to self")
            elif state == 1:
                resp = "Whooo??"
            elif state == 2:
                resp = "*chika* *chika* Slim Shady."
            websocket_state[websocket_id] = (state + 1) % 3
            return resp

      ```

      ```python {{title: 'typed'}}

    @websocket.on("message")
    async def message(ws: WebSocketConnector, msg: str, global_dependencies) -> str:
        global websocket_state
        websocket_id = ws.id
        state = websocket_state[websocket_id]
        resp = ""
        if state == 0:
            resp = "Whaaat??"
            await ws.async_broadcast("This is a broadcast message")
            ws.sync_send_to(websocket_id, "This is a message to self")
        elif state == 1:
            resp = "Whooo??"
        elif state == 2:
            resp = "*chika* *chika* Slim Shady."
        websocket_state[websocket_id] = (state + 1) % 3
        return resp

      ```
    </CodeGroup>
  </Col>
</Row>

---

## What's next?

As the codebase grew, Batman wanted to onboard the justice league to help him manage the application. 

Robyn told him about the different ways he could scale his application, and how to use views and subrouters to make his code more readable. 


- [Views and SubRouters](/documentation/api_reference/views)




